<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>readme-dev – BON in a Box</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">BON in a Box</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./how_to_install.html"> 
<span class="menu-text">How to Install</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./how_to_contribute.html"> 
<span class="menu-text">How to Contribute</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./working_with_stac.html"> 
<span class="menu-text">Working with STAC</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#developer-documentation" id="toc-developer-documentation" class="nav-link active" data-scroll-target="#developer-documentation">Developer documentation</a>
  <ul class="collapse">
  <li><a href="#contributing" id="toc-contributing" class="nav-link" data-scroll-target="#contributing">Contributing</a></li>
  <li><a href="#getting-the-code" id="toc-getting-the-code" class="nav-link" data-scroll-target="#getting-the-code">Getting the code</a></li>
  <li><a href="#ide-setup" id="toc-ide-setup" class="nav-link" data-scroll-target="#ide-setup">IDE setup</a></li>
  <li><a href="#launching-the-dockers-in-development-mode" id="toc-launching-the-dockers-in-development-mode" class="nav-link" data-scroll-target="#launching-the-dockers-in-development-mode">Launching the dockers in development mode</a></li>
  <li><a href="#releasing-a-server-version" id="toc-releasing-a-server-version" class="nav-link" data-scroll-target="#releasing-a-server-version">Releasing a server version</a>
  <ul class="collapse">
  <li><a href="#creating-a-staging-build" id="toc-creating-a-staging-build" class="nav-link" data-scroll-target="#creating-a-staging-build">Creating a staging build</a></li>
  <li><a href="#public-release" id="toc-public-release" class="nav-link" data-scroll-target="#public-release">Public release</a></li>
  <li><a href="#debugging-prod-servers" id="toc-debugging-prod-servers" class="nav-link" data-scroll-target="#debugging-prod-servers">Debugging prod servers</a></li>
  </ul></li>
  <li><a href="#microservice-infrastructure" id="toc-microservice-infrastructure" class="nav-link" data-scroll-target="#microservice-infrastructure">Microservice infrastructure</a></li>
  <li><a href="#script-lifecycle-artifacts" id="toc-script-lifecycle-artifacts" class="nav-link" data-scroll-target="#script-lifecycle-artifacts">Script lifecycle &amp; artifacts</a></li>
  <li><a href="#openapi-specification" id="toc-openapi-specification" class="nav-link" data-scroll-target="#openapi-specification">OpenAPI specification</a>
  <ul class="collapse">
  <li><a href="#single-script-scenario" id="toc-single-script-scenario" class="nav-link" data-scroll-target="#single-script-scenario">Single-script scenario</a></li>
  <li><a href="#pipeline-scenario" id="toc-pipeline-scenario" class="nav-link" data-scroll-target="#pipeline-scenario">Pipeline scenario</a></li>
  <li><a href="#editing-the-openapi-specification-of-the-script-server" id="toc-editing-the-openapi-specification-of-the-script-server" class="nav-link" data-scroll-target="#editing-the-openapi-specification-of-the-script-server">Editing the OpenAPI specification of the script-server</a></li>
  </ul></li>
  <li><a href="#debugging-signal-forwarding" id="toc-debugging-signal-forwarding" class="nav-link" data-scroll-target="#debugging-signal-forwarding">Debugging signal forwarding</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="developer-documentation" class="level1">
<h1>Developer documentation</h1>
<section id="contributing" class="level2">
<h2 class="anchored" data-anchor-id="contributing">Contributing</h2>
<p>If you wish to contribute code to this pipeline engine, please let us know at web@geobon.org.</p>
<p>The recommended method is to setup an instance of BON in a Box somewhere you can easily play with the script files, using the local or remote setup in the user documentation. You can create a branch or fork to save your work. Once complete, open a pull request to this repository. The pull request will be peer-reviewed before acceptation.</p>
</section>
<section id="getting-the-code" class="level2">
<h2 class="anchored" data-anchor-id="getting-the-code">Getting the code</h2>
<p>The code in this repository runs an engine, but the engine needs content! Here are the steps to start the server in development mode with the BON in a Box scripts and pipelines:</p>
<ol start="0" type="1">
<li>docker and docker compose must be installed.</li>
<li>Clone this repo: <code>git clone git@github.com:GEO-BON/bon-in-a-box-pipeline-engine.git pipeline-engine</code></li>
<li><code>cd pipeline-engine</code></li>
<li>Clone the BON in a Box repo (or any compatible repo of your choice) <strong>into the pipeline-repo folder</strong>: <code>git clone git@github.com:GEO-BON/bon-in-a-box-pipelines.git pipeline-repo</code></li>
<li>Create a runner.env file as per <a href="https://geo-bon.github.io/bon-in-a-box-pipeline-engine/how_to_install.html#deploying-the-servers-locally">user instructions</a>.</li>
<li><code>cd ..</code></li>
<li>Pull the pre-compiled images: <code>./dev-server.sh pull</code></li>
</ol>
</section>
<section id="ide-setup" class="level2">
<h2 class="anchored" data-anchor-id="ide-setup">IDE setup</h2>
<p>For the global project, Visual Studio Code. Recommended extensions:</p>
<ul>
<li>Git graph</li>
<li>Markdown Preview Mermaid</li>
<li>Mermaid Markdown Syntax Highlighting</li>
</ul>
<p>For the script-server (Kotlin code), IntelliJ Idea. Note that on Linux there will be an ownership conflict between gradle files generated by the development docker and those from the IDE. To solve this, make sure to stop the dockers and run <code>sudo chown -R &lt;yourinfo&gt;:&lt;yourinfo&gt; .</code> before running the tests in IntelliJ.</p>
</section>
<section id="launching-the-dockers-in-development-mode" class="level2">
<h2 class="anchored" data-anchor-id="launching-the-dockers-in-development-mode">Launching the dockers in development mode</h2>
<ol type="1">
<li><p>Build the remaining images: <code>./dev-server.sh build</code></p></li>
<li><p>Start the development server: <code>./dev-server.sh up</code></p>
<ul>
<li>If there is a container name conflict, run <code>./dev-server.sh clean</code></li>
</ul></li>
</ol>
<p>This command enables:</p>
<ul>
<li>OpenAPI editor at http://localhost/swagger/</li>
<li>UI server: React automatic hot-swapping</li>
<li>Script-server: Kotlin hot-swapping by launching <a href="../script-server/hotswap.sh">./script-server/hotswap.sh</a></li>
<li>NGINX: <a href="../http-proxy/conf.d/ngnix.conf">http-proxy/conf.d/ngnix.conf</a> will be loaded</li>
</ul>
<p>Once in a while you should use <code>docker compose -f compose.yml -f compose.dev.yml pull</code> to have the latest base images.</p>
</section>
<section id="releasing-a-server-version" class="level2">
<h2 class="anchored" data-anchor-id="releasing-a-server-version">Releasing a server version</h2>
<p>The servers are versionned by date of build of the docker image. One can check the version in the version tab of the UI.</p>
<section id="creating-a-staging-build" class="level3">
<h3 class="anchored" data-anchor-id="creating-a-staging-build">Creating a staging build</h3>
<ol type="1">
<li>Create a branch that ends with “staging” from the head of the main branch.</li>
<li>Merge your changes to that branch. The docker hub GH action will trigger for branch main and any branch with name ending by “staging”. The branch name is appended to the tag of the docker image. See
<ul>
<li><a href=".github/workflows/docker_ui.yml">.github/workflows/docker_script-server.yml</a></li>
<li><a href=".github/workflows/docker_ui.yml">.github/workflows/docker_ui.yml</a></li>
</ul></li>
<li><strong>Caveat:</strong> this only compiles the image where the paths were modified. For example, if <code>viewer</code> folder is modified, only the gateway will be rebuilt. However, the server will look for both images with the same prefix. In this case <code>script-server-staging</code> might not exist, or might be outdated. It is possible to launch the build of the script-server manually to make sure it exists and is up to date.
<ol type="1">
<li>On github website, navigate to the Actions tab</li>
<li>open the desired action</li>
<li>Click on the arrow next to “run workflow”</li>
<li>Select the desired staging branch</li>
<li>Run workflow</li>
<li>Wait for completion</li>
</ol></li>
<li>It is now possible to test the staging prod servers by running <code>./server-up.sh &lt;branchname&gt;</code>. The launch script will look for this special tag in the docker hub.For example, <code>./server-up.sh staging</code> will download and use both “gateway-staging” and “script-server-staging” images.</li>
<li>Send the above command to a few beta users.</li>
</ol>
</section>
<section id="public-release" class="level3">
<h3 class="anchored" data-anchor-id="public-release">Public release</h3>
<p>The changes are live as soon as they are merged to main branch: the dockers are built, pushed to <a href="https://hub.docker.com/r/geobon/bon-in-a-box">geobon’s docker hub</a>, and next time someone starts the server, the new dockers will be pulled.</p>
</section>
<section id="debugging-prod-servers" class="level3">
<h3 class="anchored" data-anchor-id="debugging-prod-servers">Debugging prod servers</h3>
<p>Yes, we all know problems occur in production that do not happen in dev mode. So in order to build and test production dockers locally, do the following:</p>
<ol type="1">
<li><p>In pipeline-repo folder, delete the .server folder.</p></li>
<li><p>Create a symbolic link from .server to the parent: <code>ln -s ../ .server</code></p></li>
<li><p>Build the server with <code>.server/prod-server.sh command build</code></p></li>
<li><p>Then run it with <code>.server/prod-server.sh command up</code></p>
<p>(<code>.server/prod-server.sh clean</code> might be needed if you get the usual name conflict error)</p></li>
<li><p>Stop the process with ctrl+c unless you used -d option in the previous command.</p></li>
</ol>
<p><em>Warning: Undo this by removing the symlink if you are to use <code>./server-up.sh</code> for a regular launch of the production servers, otherwise it will checkout files in your parent pipeline engine repo though the symlink.</em></p>
</section>
</section>
<section id="microservice-infrastructure" class="level2">
<h2 class="anchored" data-anchor-id="microservice-infrastructure">Microservice infrastructure</h2>
<pre class="mermaid"><code>stateDiagram-v2
    state "script-server" as script
    state "scripts (static)" as scripts
    state "output (static)" as output
    state "R runner" as r
    state "Julia runner" as julia

    [*] --&gt; ngnix
    ngnix --&gt; ui
    ngnix --&gt; viewer
    ngnix --&gt; script
    ngnix --&gt; output
    script --&gt; scripts
    script --&gt; r
    script --&gt; julia</code></pre>
<ul>
<li>ui and viewer: React front-end. In production, those are served statically in the NGINX gateway.</li>
<li>script-server: Running scripts and pipeline orchestration</li>
<li>R runner: Docker dedicated to runs R code, with most relevant packages pre-installed</li>
<li>Julia runner: Docker dedicated to runs Julia code</li>
</ul>
<p>In addition to these services,</p>
<ul>
<li><a href="../scripts/">scripts</a> folder contains all the scripts that can be run.</li>
<li><a href="../output/">output</a> folder contains all scripts result.</li>
</ul>
</section>
<section id="script-lifecycle-artifacts" class="level2">
<h2 class="anchored" data-anchor-id="script-lifecycle-artifacts">Script lifecycle &amp; artifacts</h2>
<pre class="mermaid"><code>flowchart TD
 never[Never ran] --&gt; running[Running]
 running --&gt; input[(- run folder\n- input.json)]
 running --&gt; log[(log file)]
 running --&gt; success{Success?}
 success --&gt; |Yes| Done
 Done --&gt; output[(output.json)]
 success --&gt; |No| Failed
 Failed --&gt; |Add error flag|output</code></pre>
</section>
<section id="openapi-specification" class="level2">
<h2 class="anchored" data-anchor-id="openapi-specification">OpenAPI specification</h2>
<p>The <a href="../script-server/api/openapi.yaml">OpenApi specification file</a> is used by the UI to launch runs and track them until completion.</p>
<section id="single-script-scenario" class="level3">
<h3 class="anchored" data-anchor-id="single-script-scenario">Single-script scenario</h3>
<pre class="mermaid"><code>sequenceDiagram
    ui-&gt;&gt;script_server: script/list
    script_server--&gt;&gt;ui: json map of scripts -&gt; names

    ui-&gt;&gt;script_server: script/{path}/info
    script_server--&gt;&gt;ui: script info json

    ui-&gt;&gt;script_server: script/run
    script_server-&gt;&gt;script: launch
    script_server--&gt;&gt;ui: runId

    loop Until output.json file generated
        ui-&gt;&gt;script_server: output/{runId}/logs.txt
        script_server--&gt;&gt;ui: logs text

        ui-&gt;&gt;script_server: output/{id}/output.json
    end


    script--&gt;&gt;script_server: output.json

    ui-&gt;&gt;script_server: output/{runId}/output.json
    script_server--&gt;&gt;ui: script output json
</code></pre>
</section>
<section id="pipeline-scenario" class="level3">
<h3 class="anchored" data-anchor-id="pipeline-scenario">Pipeline scenario</h3>
<pre class="mermaid"><code>sequenceDiagram
    ui-&gt;&gt;script_server: pipeline/list
    script_server--&gt;&gt;ui: json map of pipeline -&gt; names

    ui-&gt;&gt;script_server: pipeline/{path}/info
    script_server--&gt;&gt;ui: pipeline info json

    ui-&gt;&gt;script_server: pipeline/{path}/run
    script_server--&gt;&gt;ui: runId
    loop For each step
        script_server-&gt;&gt;script: run
        Note right of script: see previous diagram
        script--&gt;&gt;script_server: output.json (script)
        ui-&gt;&gt;script_server: pipeline/{runId}/outputs
        script_server--&gt;&gt;ui: pipelineOutput.json (pipeline)
    end
</code></pre>
<p>Every second, the UI polls for:</p>
<ul>
<li>pipelineOutput.json from the pipeline, to get the output folders of individual scripts. Stops polling when pipeline stops.</li>
<li>logs.txt of individual scripts, for realtime logging, only if log section is opened. Stops when individual script completes, or when log section closed.</li>
<li>output.json of individual scripts, to know when script completes and display its outputs. Stops when script stops.</li>
</ul>
</section>
<section id="editing-the-openapi-specification-of-the-script-server" class="level3">
<h3 class="anchored" data-anchor-id="editing-the-openapi-specification-of-the-script-server">Editing the OpenAPI specification of the script-server</h3>
<ol type="1">
<li>Using http://localhost/swagger, edit the specification.</li>
<li>Copy the result to <a href="../script-server/api/openapi.yaml">script-server/api/openapi.yaml</a></li>
<li>Use <a href="../ui/BonInABoxScriptService/generate-client.sh">ui/BonInABoxScriptService/generate-client.sh</a> and <a href="../script-server/generate-server-openapitools.sh">script-server/generate-server-openapitools.sh</a> to regenerate the client and the server.</li>
<li>Merge carefully, not all generated code is to be kept.</li>
<li>Implement the gaps.</li>
</ol>
</section>
</section>
<section id="debugging-signal-forwarding" class="level2">
<h2 class="anchored" data-anchor-id="debugging-signal-forwarding">Debugging signal forwarding</h2>
<p>Since runner-conda and runner-julia run in a separate docker, when the user stops the pipeline, the signal must go from the script-server, to the runner, to the running script. Docker does not allow this by default, this is why we save the PID in a file and use a separate exec command to kill the process.</p>
<p>The PID file is called <code>.pid</code> and is located in the output folder of the run. It is deleted when the script completes. For details, see <a href="https://github.com/GEO-BON/bon-in-a-box-pipeline-engine/blob/main/script-server/src/main/kotlin/org/geobon/script/ScriptRun.kt">ScriptRun.kt</a>.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>